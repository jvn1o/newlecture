구조: 
java 언어 + 플랫폼 API
언어(CPU를 이용한 프로그램)가 도구(여러가지 장치)를 사용하도록 접합제(인터페이스)로 결합해준다.
나노가(전력) 낮아지면서 모바일 칩(ARM)의 활용성이 높아졌다.

# 플랫폼: 함수 형태, 인터페이스 대상에 따라 종류가 변형됨

선정 순서: 플랫폼 선정 -> API 선정

함수: 
함수의 정의를 통하여 코드를 파편화(세분화)할 수 있어 가독성이 높아진다. 
또한, 코드의 집중화와 코드의 은닉화의 이점도 얻을 수 있다.

# 컴파일러 javac: 단순한 번역
# 인터프리터 (JIT 컴파일러) java: 당장의 실행을 위한, 실행하면서 번역

JIT(JustInTime) Compiler: 
CPU마다 다른 컴파일러를 가진다.
필요한 것만 컴파일, 메모리 삭제를 하지않거나 그러지 못하는 경우가 있을 대 
메모리의 누수가 발생하지 않도록 해주는 것.

Garbage Collector: 
JIT에서 필요없는 메모리를 삭제하는 역할을 한다.
이후 메모리가 삭제된 빈 공간을 메울 때
C++에서 사용하던 포인터(주소)를 사용하지 않고, 참조변수를 이용한다.

JAVA Language의 특징:
간결성
# delete 제거
# 객체의 포인터 제거
# 모든 포인터 제거
# struct 키워드 제거
# 함수 x 메소드로만 사용하도록 제약
# 다양한 인코딩 문자열 기능 개선
언어에 컬렉션 포함(요즘 언어는 default이긴 함)
완전한 객체지향 언어  # 만들어진 당시에는 큰 장점이었지만 현재에는 default값

WORA(Write Once Run Anywhere): 
LINUX - UNIX - Windows 사이에서 함수의 작성이 다 달라서 동일하게 
변환해주는 것이 'Java Platform'이다.
단순하게 번역하고 배포하는 방식은, OS마다 체계가 다르기 때문에 
인터프리터 방식만 사용하여 번역하지 않고 자바코드를 배포하는 방식으로 사용한다.
하지만 속도가 느리다는 단점을 보완하기 위해 2번의 번역을 거치는 방식으로 발전하였는데
[ 1.자바 코드 -> 2.컴파일러 -> 3.바이트 코드 -> 4.인터프리터 -> 5.기계 코드 ] 의 과정을 거친다.
# 1, 2, 3: (1단계 '형태소 분석' 2단계 '구문 분석' 3단계 '의미 분석', 이 과정에서 오랜 시간이 소요된다)
# 3, 4, 5: (4단계 '중간 코드' 5단계 '최적화' 6단계 '물리 코드')

